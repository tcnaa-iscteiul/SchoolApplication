{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { gridAggregationLookupSelector } from './gridAggregationSelectors';\nimport { GridFooterCell } from '../../../components/GridFooterCell';\nimport { GridAggregationHeader } from '../../../components/GridAggregationHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\n\nconst getAggregationValueWrappedValueGetter = _ref => {\n  let {\n    value: valueGetter,\n    getCellAggregationResult\n  } = _ref;\n\n  const wrappedValueGetter = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _cellAggregationResul;\n\n      return (_cellAggregationResul = cellAggregationResult == null ? void 0 : cellAggregationResult.value) != null ? _cellAggregationResul : null;\n    }\n\n    if (valueGetter) {\n      return valueGetter(params);\n    }\n\n    return params.row[params.field];\n  };\n\n  return wrappedValueGetter;\n};\n\nconst getAggregationValueWrappedValueFormatter = _ref2 => {\n  let {\n    value: valueFormatter,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref2;\n\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n\n  const wrappedValueFormatter = params => {\n    if (params.id != null) {\n      const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter(params);\n      }\n    }\n\n    if (valueFormatter) {\n      return valueFormatter(params);\n    }\n\n    return params.value;\n  };\n\n  return wrappedValueFormatter;\n};\n\nconst getAggregationValueWrappedRenderCell = _ref3 => {\n  let {\n    value: renderCell,\n    aggregationRule,\n    getCellAggregationResult\n  } = _ref3;\n\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _aggregationFunction$;\n\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/_jsx(GridFooterCell, _extends({}, params));\n        }\n\n        return params.formattedValue;\n      }\n\n      const aggregationMeta = {\n        hasCellUnit: (_aggregationFunction$ = aggregationRule.aggregationFunction.hasCellUnit) != null ? _aggregationFunction$ : true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell(_extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n\n    return renderCell(params);\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Skips the filtering for aggregated rows\n */\n\n\nconst getWrappedFilterOperators = _ref4 => {\n  let {\n    value: filterOperators,\n    getCellAggregationResult\n  } = _ref4;\n  return filterOperators.map(operator => {\n    return _extends({}, operator, {\n      getApplyFilterFn: (filterItem, column) => {\n        const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n        if (!originalFn) {\n          return null;\n        }\n\n        return params => {\n          if (getCellAggregationResult(params.id, params.field) != null) {\n            return true;\n          }\n\n          return originalFn(params);\n        };\n      }\n    });\n  });\n};\n/**\n * Add the aggregation method around the header name\n */\n\n\nconst getWrappedRenderHeader = _ref5 => {\n  let {\n    value: renderHeader,\n    aggregationRule\n  } = _ref5;\n\n  const wrappedRenderCell = params => {\n    const aggregationMeta = {\n      aggregationRule\n    };\n\n    if (!renderHeader) {\n      return /*#__PURE__*/_jsx(GridAggregationHeader, _extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    return renderHeader(_extends({}, params, {\n      aggregation: aggregationMeta\n    }));\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\n\n\nexport const wrapColumnWithAggregationValue = _ref6 => {\n  let {\n    column,\n    apiRef,\n    aggregationRule\n  } = _ref6;\n\n  const getCellAggregationResult = (id, field) => {\n    var _parent, _gridAggregationLooku;\n\n    let cellAggregationPosition = null;\n\n    if (id.toString().startsWith('auto-generated-row-')) {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n\n    if (cellAggregationPosition == null) {\n      return null;\n    } // TODO: Add custom root id\n\n\n    const groupId = cellAggregationPosition === 'inline' ? id : (_parent = apiRef.current.getRowNode(id).parent) != null ? _parent : '';\n    const aggregationResult = (_gridAggregationLooku = gridAggregationLookupSelector(apiRef)[groupId]) == null ? void 0 : _gridAggregationLooku[field];\n\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n\n    return aggregationResult;\n  };\n\n  const aggregationWrappedProperties = {};\n\n  const wrappedColumn = _extends({}, column, {\n    aggregationWrappedProperties\n  });\n\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n\n    if (wrappedProperty !== originalValue) {\n      aggregationWrappedProperties[property] = {\n        original: originalValue,\n        wrapped: wrappedProperty\n      };\n      wrappedColumn[property] = wrappedProperty;\n    }\n  };\n\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n\n  if (Object.keys(aggregationWrappedProperties).length === 0) {\n    return column;\n  }\n\n  return wrappedColumn;\n};\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\n\nexport const unwrapColumnFromAggregation = _ref7 => {\n  let {\n    column\n  } = _ref7;\n\n  if (!column.aggregationWrappedProperties) {\n    return column;\n  }\n\n  const originalProperties = Object.entries(column.aggregationWrappedProperties);\n\n  if (originalProperties.length === 0) {\n    return column;\n  }\n\n  const unwrappedColumn = _extends({}, column);\n\n  originalProperties.forEach(_ref8 => {\n    let [propertyName, {\n      original,\n      wrapped\n    }] = _ref8;\n\n    // The value changed since we wrapped it\n    if (wrapped !== column[propertyName]) {\n      return;\n    }\n\n    unwrappedColumn[propertyName] = original;\n  });\n  return unwrappedColumn;\n};","map":{"version":3,"names":["_extends","React","gridAggregationLookupSelector","GridFooterCell","GridAggregationHeader","jsx","_jsx","AGGREGATION_WRAPPABLE_PROPERTIES","getAggregationValueWrappedValueGetter","value","valueGetter","getCellAggregationResult","wrappedValueGetter","params","cellAggregationResult","id","field","_cellAggregationResul","row","getAggregationValueWrappedValueFormatter","valueFormatter","aggregationRule","aggregationFunction","wrappedValueFormatter","getAggregationValueWrappedRenderCell","renderCell","wrappedRenderCell","_aggregationFunction$","position","formattedValue","aggregationMeta","hasCellUnit","aggregationFunctionName","aggregation","getWrappedFilterOperators","filterOperators","map","operator","getApplyFilterFn","filterItem","column","originalFn","getWrappedRenderHeader","renderHeader","wrapColumnWithAggregationValue","apiRef","_parent","_gridAggregationLooku","cellAggregationPosition","toString","startsWith","groupId","current","getRowNode","parent","aggregationResult","aggregationWrappedProperties","wrappedColumn","wrapColumnProperty","property","wrapper","originalValue","wrappedProperty","colDef","original","wrapped","Object","keys","length","unwrapColumnFromAggregation","originalProperties","entries","unwrappedColumn","forEach","propertyName"],"sources":["C:/Users/Utilizador/OneDrive/Ambiente de Trabalho/SchoolApplication/frontend/node_modules/@mui/x-data-grid-premium/hooks/features/aggregation/wrapColumnWithAggregation.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { gridAggregationLookupSelector } from './gridAggregationSelectors';\nimport { GridFooterCell } from '../../../components/GridFooterCell';\nimport { GridAggregationHeader } from '../../../components/GridAggregationHeader';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst AGGREGATION_WRAPPABLE_PROPERTIES = ['valueGetter', 'valueFormatter', 'renderCell', 'renderHeader', 'filterOperators'];\n\nconst getAggregationValueWrappedValueGetter = ({\n  value: valueGetter,\n  getCellAggregationResult\n}) => {\n  const wrappedValueGetter = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _cellAggregationResul;\n\n      return (_cellAggregationResul = cellAggregationResult == null ? void 0 : cellAggregationResult.value) != null ? _cellAggregationResul : null;\n    }\n\n    if (valueGetter) {\n      return valueGetter(params);\n    }\n\n    return params.row[params.field];\n  };\n\n  return wrappedValueGetter;\n};\n\nconst getAggregationValueWrappedValueFormatter = ({\n  value: valueFormatter,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  // If neither the inline aggregation function nor the footer aggregation function have a custom value formatter,\n  // Then we don't wrap the column value formatter\n  if (!aggregationRule.aggregationFunction.valueFormatter) {\n    return valueFormatter;\n  }\n\n  const wrappedValueFormatter = params => {\n    if (params.id != null) {\n      const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n      if (cellAggregationResult != null) {\n        return aggregationRule.aggregationFunction.valueFormatter(params);\n      }\n    }\n\n    if (valueFormatter) {\n      return valueFormatter(params);\n    }\n\n    return params.value;\n  };\n\n  return wrappedValueFormatter;\n};\n\nconst getAggregationValueWrappedRenderCell = ({\n  value: renderCell,\n  aggregationRule,\n  getCellAggregationResult\n}) => {\n  const wrappedRenderCell = params => {\n    const cellAggregationResult = getCellAggregationResult(params.id, params.field);\n\n    if (cellAggregationResult != null) {\n      var _aggregationFunction$;\n\n      if (!renderCell) {\n        if (cellAggregationResult.position === 'footer') {\n          return /*#__PURE__*/_jsx(GridFooterCell, _extends({}, params));\n        }\n\n        return params.formattedValue;\n      }\n\n      const aggregationMeta = {\n        hasCellUnit: (_aggregationFunction$ = aggregationRule.aggregationFunction.hasCellUnit) != null ? _aggregationFunction$ : true,\n        aggregationFunctionName: aggregationRule.aggregationFunctionName\n      };\n      return renderCell(_extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    if (!renderCell) {\n      return params.formattedValue;\n    }\n\n    return renderCell(params);\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Skips the filtering for aggregated rows\n */\n\n\nconst getWrappedFilterOperators = ({\n  value: filterOperators,\n  getCellAggregationResult\n}) => filterOperators.map(operator => {\n  return _extends({}, operator, {\n    getApplyFilterFn: (filterItem, column) => {\n      const originalFn = operator.getApplyFilterFn(filterItem, column);\n\n      if (!originalFn) {\n        return null;\n      }\n\n      return params => {\n        if (getCellAggregationResult(params.id, params.field) != null) {\n          return true;\n        }\n\n        return originalFn(params);\n      };\n    }\n  });\n});\n/**\n * Add the aggregation method around the header name\n */\n\n\nconst getWrappedRenderHeader = ({\n  value: renderHeader,\n  aggregationRule\n}) => {\n  const wrappedRenderCell = params => {\n    const aggregationMeta = {\n      aggregationRule\n    };\n\n    if (!renderHeader) {\n      return /*#__PURE__*/_jsx(GridAggregationHeader, _extends({}, params, {\n        aggregation: aggregationMeta\n      }));\n    }\n\n    return renderHeader(_extends({}, params, {\n      aggregation: aggregationMeta\n    }));\n  };\n\n  return wrappedRenderCell;\n};\n/**\n * Add a wrapper around each wrappable property of the column to customize the behavior of the aggregation cells.\n */\n\n\nexport const wrapColumnWithAggregationValue = ({\n  column,\n  apiRef,\n  aggregationRule\n}) => {\n  const getCellAggregationResult = (id, field) => {\n    var _parent, _gridAggregationLooku;\n\n    let cellAggregationPosition = null;\n\n    if (id.toString().startsWith('auto-generated-row-')) {\n      cellAggregationPosition = 'inline';\n    } else if (id.toString().startsWith('auto-generated-group-footer-')) {\n      cellAggregationPosition = 'footer';\n    }\n\n    if (cellAggregationPosition == null) {\n      return null;\n    } // TODO: Add custom root id\n\n\n    const groupId = cellAggregationPosition === 'inline' ? id : (_parent = apiRef.current.getRowNode(id).parent) != null ? _parent : '';\n    const aggregationResult = (_gridAggregationLooku = gridAggregationLookupSelector(apiRef)[groupId]) == null ? void 0 : _gridAggregationLooku[field];\n\n    if (!aggregationResult || aggregationResult.position !== cellAggregationPosition) {\n      return null;\n    }\n\n    return aggregationResult;\n  };\n\n  const aggregationWrappedProperties = {};\n\n  const wrappedColumn = _extends({}, column, {\n    aggregationWrappedProperties\n  });\n\n  const wrapColumnProperty = (property, wrapper) => {\n    const originalValue = column[property];\n    const wrappedProperty = wrapper({\n      apiRef,\n      value: originalValue,\n      colDef: column,\n      aggregationRule,\n      getCellAggregationResult\n    });\n\n    if (wrappedProperty !== originalValue) {\n      aggregationWrappedProperties[property] = {\n        original: originalValue,\n        wrapped: wrappedProperty\n      };\n      wrappedColumn[property] = wrappedProperty;\n    }\n  };\n\n  wrapColumnProperty('valueGetter', getAggregationValueWrappedValueGetter);\n  wrapColumnProperty('valueFormatter', getAggregationValueWrappedValueFormatter);\n  wrapColumnProperty('renderCell', getAggregationValueWrappedRenderCell);\n  wrapColumnProperty('renderHeader', getWrappedRenderHeader);\n  wrapColumnProperty('filterOperators', getWrappedFilterOperators);\n\n  if (Object.keys(aggregationWrappedProperties).length === 0) {\n    return column;\n  }\n\n  return wrappedColumn;\n};\n/**\n * Remove the aggregation wrappers around the wrappable properties of the column.\n */\n\nexport const unwrapColumnFromAggregation = ({\n  column\n}) => {\n  if (!column.aggregationWrappedProperties) {\n    return column;\n  }\n\n  const originalProperties = Object.entries(column.aggregationWrappedProperties);\n\n  if (originalProperties.length === 0) {\n    return column;\n  }\n\n  const unwrappedColumn = _extends({}, column);\n\n  originalProperties.forEach(([propertyName, {\n    original,\n    wrapped\n  }]) => {\n    // The value changed since we wrapped it\n    if (wrapped !== column[propertyName]) {\n      return;\n    }\n\n    unwrappedColumn[propertyName] = original;\n  });\n  return unwrappedColumn;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}